// Generated by jextract

package com.sunya.netchdf.hdf5Clib.ffm;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class H5FD_class_t {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("name"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("maxaddr"),
        Constants$root.C_INT$LAYOUT.withName("fc_degree"),
        MemoryLayout.paddingLayout(32),
        Constants$root.C_POINTER$LAYOUT.withName("terminate"),
        Constants$root.C_POINTER$LAYOUT.withName("sb_size"),
        Constants$root.C_POINTER$LAYOUT.withName("sb_encode"),
        Constants$root.C_POINTER$LAYOUT.withName("sb_decode"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("fapl_size"),
        Constants$root.C_POINTER$LAYOUT.withName("fapl_get"),
        Constants$root.C_POINTER$LAYOUT.withName("fapl_copy"),
        Constants$root.C_POINTER$LAYOUT.withName("fapl_free"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("dxpl_size"),
        Constants$root.C_POINTER$LAYOUT.withName("dxpl_copy"),
        Constants$root.C_POINTER$LAYOUT.withName("dxpl_free"),
        Constants$root.C_POINTER$LAYOUT.withName("open"),
        Constants$root.C_POINTER$LAYOUT.withName("close"),
        Constants$root.C_POINTER$LAYOUT.withName("cmp"),
        Constants$root.C_POINTER$LAYOUT.withName("query"),
        Constants$root.C_POINTER$LAYOUT.withName("get_type_map"),
        Constants$root.C_POINTER$LAYOUT.withName("alloc"),
        Constants$root.C_POINTER$LAYOUT.withName("free"),
        Constants$root.C_POINTER$LAYOUT.withName("get_eoa"),
        Constants$root.C_POINTER$LAYOUT.withName("set_eoa"),
        Constants$root.C_POINTER$LAYOUT.withName("get_eof"),
        Constants$root.C_POINTER$LAYOUT.withName("get_handle"),
        Constants$root.C_POINTER$LAYOUT.withName("read"),
        Constants$root.C_POINTER$LAYOUT.withName("write"),
        Constants$root.C_POINTER$LAYOUT.withName("flush"),
        Constants$root.C_POINTER$LAYOUT.withName("truncate"),
        Constants$root.C_POINTER$LAYOUT.withName("lock"),
        Constants$root.C_POINTER$LAYOUT.withName("unlock"),
        MemoryLayout.sequenceLayout(7, Constants$root.C_INT$LAYOUT).withName("fl_map"),
        MemoryLayout.paddingLayout(32)
    ).withName("H5FD_class_t");
    public static MemoryLayout $LAYOUT() {
        return H5FD_class_t.$struct$LAYOUT;
    }
    static final VarHandle name$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("name"));
    public static VarHandle name$VH() {
        return H5FD_class_t.name$VH;
    }
    public static MemoryAddress name$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.name$VH.get(seg);
    }
    public static void name$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.name$VH.set(seg, x);
    }
    public static MemoryAddress name$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.name$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void name$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.name$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle maxaddr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("maxaddr"));
    public static VarHandle maxaddr$VH() {
        return H5FD_class_t.maxaddr$VH;
    }
    public static long maxaddr$get(MemorySegment seg) {
        return (long)H5FD_class_t.maxaddr$VH.get(seg);
    }
    public static void maxaddr$set( MemorySegment seg, long x) {
        H5FD_class_t.maxaddr$VH.set(seg, x);
    }
    public static long maxaddr$get(MemorySegment seg, long index) {
        return (long)H5FD_class_t.maxaddr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void maxaddr$set(MemorySegment seg, long index, long x) {
        H5FD_class_t.maxaddr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle fc_degree$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fc_degree"));
    public static VarHandle fc_degree$VH() {
        return H5FD_class_t.fc_degree$VH;
    }
    public static int fc_degree$get(MemorySegment seg) {
        return (int)H5FD_class_t.fc_degree$VH.get(seg);
    }
    public static void fc_degree$set( MemorySegment seg, int x) {
        H5FD_class_t.fc_degree$VH.set(seg, x);
    }
    public static int fc_degree$get(MemorySegment seg, long index) {
        return (int)H5FD_class_t.fc_degree$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fc_degree$set(MemorySegment seg, long index, int x) {
        H5FD_class_t.fc_degree$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor terminate$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT);
    static final MethodHandle terminate$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.terminate$FUNC
    );
    public interface terminate {

        int apply();
        static MemorySegment allocate(terminate fi, MemorySession session) {
            return RuntimeHelper.upcallStub(terminate.class, fi, H5FD_class_t.terminate$FUNC, session);
        }
        static terminate ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    return (int)H5FD_class_t.terminate$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle terminate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("terminate"));
    public static VarHandle terminate$VH() {
        return H5FD_class_t.terminate$VH;
    }
    public static MemoryAddress terminate$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.terminate$VH.get(seg);
    }
    public static void terminate$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.terminate$VH.set(seg, x);
    }
    public static MemoryAddress terminate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.terminate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void terminate$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.terminate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static terminate terminate (MemorySegment segment, MemorySession session) {
        return terminate.ofAddress(terminate$get(segment), session);
    }
    static final FunctionDescriptor sb_size$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle sb_size$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.sb_size$FUNC
    );
    public interface sb_size {

        long apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(sb_size fi, MemorySession session) {
            return RuntimeHelper.upcallStub(sb_size.class, fi, H5FD_class_t.sb_size$FUNC, session);
        }
        static sb_size ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (long)H5FD_class_t.sb_size$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle sb_size$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("sb_size"));
    public static VarHandle sb_size$VH() {
        return H5FD_class_t.sb_size$VH;
    }
    public static MemoryAddress sb_size$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.sb_size$VH.get(seg);
    }
    public static void sb_size$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.sb_size$VH.set(seg, x);
    }
    public static MemoryAddress sb_size$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.sb_size$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void sb_size$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.sb_size$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static sb_size sb_size (MemorySegment segment, MemorySession session) {
        return sb_size.ofAddress(sb_size$get(segment), session);
    }
    static final FunctionDescriptor sb_encode$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle sb_encode$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.sb_encode$FUNC
    );
    public interface sb_encode {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(sb_encode fi, MemorySession session) {
            return RuntimeHelper.upcallStub(sb_encode.class, fi, H5FD_class_t.sb_encode$FUNC, session);
        }
        static sb_encode ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)H5FD_class_t.sb_encode$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle sb_encode$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("sb_encode"));
    public static VarHandle sb_encode$VH() {
        return H5FD_class_t.sb_encode$VH;
    }
    public static MemoryAddress sb_encode$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.sb_encode$VH.get(seg);
    }
    public static void sb_encode$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.sb_encode$VH.set(seg, x);
    }
    public static MemoryAddress sb_encode$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.sb_encode$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void sb_encode$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.sb_encode$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static sb_encode sb_encode (MemorySegment segment, MemorySession session) {
        return sb_encode.ofAddress(sb_encode$get(segment), session);
    }
    static final FunctionDescriptor sb_decode$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle sb_decode$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.sb_decode$FUNC
    );
    public interface sb_decode {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(sb_decode fi, MemorySession session) {
            return RuntimeHelper.upcallStub(sb_decode.class, fi, H5FD_class_t.sb_decode$FUNC, session);
        }
        static sb_decode ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)H5FD_class_t.sb_decode$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle sb_decode$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("sb_decode"));
    public static VarHandle sb_decode$VH() {
        return H5FD_class_t.sb_decode$VH;
    }
    public static MemoryAddress sb_decode$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.sb_decode$VH.get(seg);
    }
    public static void sb_decode$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.sb_decode$VH.set(seg, x);
    }
    public static MemoryAddress sb_decode$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.sb_decode$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void sb_decode$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.sb_decode$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static sb_decode sb_decode (MemorySegment segment, MemorySession session) {
        return sb_decode.ofAddress(sb_decode$get(segment), session);
    }
    static final VarHandle fapl_size$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fapl_size"));
    public static VarHandle fapl_size$VH() {
        return H5FD_class_t.fapl_size$VH;
    }
    public static long fapl_size$get(MemorySegment seg) {
        return (long)H5FD_class_t.fapl_size$VH.get(seg);
    }
    public static void fapl_size$set( MemorySegment seg, long x) {
        H5FD_class_t.fapl_size$VH.set(seg, x);
    }
    public static long fapl_size$get(MemorySegment seg, long index) {
        return (long)H5FD_class_t.fapl_size$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fapl_size$set(MemorySegment seg, long index, long x) {
        H5FD_class_t.fapl_size$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor fapl_get$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fapl_get$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.fapl_get$FUNC
    );
    public interface fapl_get {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(fapl_get fi, MemorySession session) {
            return RuntimeHelper.upcallStub(fapl_get.class, fi, H5FD_class_t.fapl_get$FUNC, session);
        }
        static fapl_get ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_get$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fapl_get$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fapl_get"));
    public static VarHandle fapl_get$VH() {
        return H5FD_class_t.fapl_get$VH;
    }
    public static MemoryAddress fapl_get$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_get$VH.get(seg);
    }
    public static void fapl_get$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.fapl_get$VH.set(seg, x);
    }
    public static MemoryAddress fapl_get$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_get$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fapl_get$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.fapl_get$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fapl_get fapl_get (MemorySegment segment, MemorySession session) {
        return fapl_get.ofAddress(fapl_get$get(segment), session);
    }
    static final FunctionDescriptor fapl_copy$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fapl_copy$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.fapl_copy$FUNC
    );
    public interface fapl_copy {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(fapl_copy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(fapl_copy.class, fi, H5FD_class_t.fapl_copy$FUNC, session);
        }
        static fapl_copy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_copy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fapl_copy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fapl_copy"));
    public static VarHandle fapl_copy$VH() {
        return H5FD_class_t.fapl_copy$VH;
    }
    public static MemoryAddress fapl_copy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_copy$VH.get(seg);
    }
    public static void fapl_copy$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.fapl_copy$VH.set(seg, x);
    }
    public static MemoryAddress fapl_copy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_copy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fapl_copy$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.fapl_copy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fapl_copy fapl_copy (MemorySegment segment, MemorySession session) {
        return fapl_copy.ofAddress(fapl_copy$get(segment), session);
    }
    static final FunctionDescriptor fapl_free$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fapl_free$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.fapl_free$FUNC
    );
    public interface fapl_free {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(fapl_free fi, MemorySession session) {
            return RuntimeHelper.upcallStub(fapl_free.class, fi, H5FD_class_t.fapl_free$FUNC, session);
        }
        static fapl_free ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)H5FD_class_t.fapl_free$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fapl_free$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fapl_free"));
    public static VarHandle fapl_free$VH() {
        return H5FD_class_t.fapl_free$VH;
    }
    public static MemoryAddress fapl_free$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_free$VH.get(seg);
    }
    public static void fapl_free$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.fapl_free$VH.set(seg, x);
    }
    public static MemoryAddress fapl_free$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.fapl_free$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fapl_free$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.fapl_free$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fapl_free fapl_free (MemorySegment segment, MemorySession session) {
        return fapl_free.ofAddress(fapl_free$get(segment), session);
    }
    static final VarHandle dxpl_size$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dxpl_size"));
    public static VarHandle dxpl_size$VH() {
        return H5FD_class_t.dxpl_size$VH;
    }
    public static long dxpl_size$get(MemorySegment seg) {
        return (long)H5FD_class_t.dxpl_size$VH.get(seg);
    }
    public static void dxpl_size$set( MemorySegment seg, long x) {
        H5FD_class_t.dxpl_size$VH.set(seg, x);
    }
    public static long dxpl_size$get(MemorySegment seg, long index) {
        return (long)H5FD_class_t.dxpl_size$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dxpl_size$set(MemorySegment seg, long index, long x) {
        H5FD_class_t.dxpl_size$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor dxpl_copy$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle dxpl_copy$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.dxpl_copy$FUNC
    );
    public interface dxpl_copy {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(dxpl_copy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(dxpl_copy.class, fi, H5FD_class_t.dxpl_copy$FUNC, session);
        }
        static dxpl_copy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)H5FD_class_t.dxpl_copy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dxpl_copy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dxpl_copy"));
    public static VarHandle dxpl_copy$VH() {
        return H5FD_class_t.dxpl_copy$VH;
    }
    public static MemoryAddress dxpl_copy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.dxpl_copy$VH.get(seg);
    }
    public static void dxpl_copy$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.dxpl_copy$VH.set(seg, x);
    }
    public static MemoryAddress dxpl_copy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.dxpl_copy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dxpl_copy$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.dxpl_copy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dxpl_copy dxpl_copy (MemorySegment segment, MemorySession session) {
        return dxpl_copy.ofAddress(dxpl_copy$get(segment), session);
    }
    static final FunctionDescriptor dxpl_free$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle dxpl_free$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.dxpl_free$FUNC
    );
    public interface dxpl_free {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(dxpl_free fi, MemorySession session) {
            return RuntimeHelper.upcallStub(dxpl_free.class, fi, H5FD_class_t.dxpl_free$FUNC, session);
        }
        static dxpl_free ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)H5FD_class_t.dxpl_free$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dxpl_free$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dxpl_free"));
    public static VarHandle dxpl_free$VH() {
        return H5FD_class_t.dxpl_free$VH;
    }
    public static MemoryAddress dxpl_free$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.dxpl_free$VH.get(seg);
    }
    public static void dxpl_free$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.dxpl_free$VH.set(seg, x);
    }
    public static MemoryAddress dxpl_free$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.dxpl_free$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dxpl_free$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.dxpl_free$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dxpl_free dxpl_free (MemorySegment segment, MemorySession session) {
        return dxpl_free.ofAddress(dxpl_free$get(segment), session);
    }
    static final FunctionDescriptor open$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle open$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.open$FUNC
    );
    public interface open {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, long _x2, long _x3);
        static MemorySegment allocate(open fi, MemorySession session) {
            return RuntimeHelper.upcallStub(open.class, fi, H5FD_class_t.open$FUNC, session);
        }
        static open ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, long __x2, long __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)H5FD_class_t.open$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open"));
    public static VarHandle open$VH() {
        return H5FD_class_t.open$VH;
    }
    public static MemoryAddress open$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.open$VH.get(seg);
    }
    public static void open$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.open$VH.set(seg, x);
    }
    public static MemoryAddress open$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.open$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.open$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open open (MemorySegment segment, MemorySession session) {
        return open.ofAddress(open$get(segment), session);
    }
    static final FunctionDescriptor close$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle close$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.close$FUNC
    );
    public interface close {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(close fi, MemorySession session) {
            return RuntimeHelper.upcallStub(close.class, fi, H5FD_class_t.close$FUNC, session);
        }
        static close ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)H5FD_class_t.close$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle close$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("close"));
    public static VarHandle close$VH() {
        return H5FD_class_t.close$VH;
    }
    public static MemoryAddress close$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.close$VH.get(seg);
    }
    public static void close$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.close$VH.set(seg, x);
    }
    public static MemoryAddress close$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.close$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void close$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.close$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static close close (MemorySegment segment, MemorySession session) {
        return close.ofAddress(close$get(segment), session);
    }
    static final FunctionDescriptor cmp$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle cmp$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.cmp$FUNC
    );
    public interface cmp {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(cmp fi, MemorySession session) {
            return RuntimeHelper.upcallStub(cmp.class, fi, H5FD_class_t.cmp$FUNC, session);
        }
        static cmp ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)H5FD_class_t.cmp$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cmp$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("cmp"));
    public static VarHandle cmp$VH() {
        return H5FD_class_t.cmp$VH;
    }
    public static MemoryAddress cmp$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.cmp$VH.get(seg);
    }
    public static void cmp$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.cmp$VH.set(seg, x);
    }
    public static MemoryAddress cmp$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.cmp$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cmp$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.cmp$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cmp cmp (MemorySegment segment, MemorySession session) {
        return cmp.ofAddress(cmp$get(segment), session);
    }
    static final FunctionDescriptor query$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle query$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.query$FUNC
    );
    public interface query {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(query fi, MemorySession session) {
            return RuntimeHelper.upcallStub(query.class, fi, H5FD_class_t.query$FUNC, session);
        }
        static query ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)H5FD_class_t.query$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle query$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("query"));
    public static VarHandle query$VH() {
        return H5FD_class_t.query$VH;
    }
    public static MemoryAddress query$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.query$VH.get(seg);
    }
    public static void query$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.query$VH.set(seg, x);
    }
    public static MemoryAddress query$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.query$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void query$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.query$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static query query (MemorySegment segment, MemorySession session) {
        return query.ofAddress(query$get(segment), session);
    }
    static final FunctionDescriptor get_type_map$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_type_map$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.get_type_map$FUNC
    );
    public interface get_type_map {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(get_type_map fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_type_map.class, fi, H5FD_class_t.get_type_map$FUNC, session);
        }
        static get_type_map ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)H5FD_class_t.get_type_map$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_type_map$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_type_map"));
    public static VarHandle get_type_map$VH() {
        return H5FD_class_t.get_type_map$VH;
    }
    public static MemoryAddress get_type_map$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_type_map$VH.get(seg);
    }
    public static void get_type_map$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.get_type_map$VH.set(seg, x);
    }
    public static MemoryAddress get_type_map$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_type_map$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_type_map$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.get_type_map$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_type_map get_type_map (MemorySegment segment, MemorySession session) {
        return get_type_map.ofAddress(get_type_map$get(segment), session);
    }
    static final FunctionDescriptor alloc$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle alloc$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.alloc$FUNC
    );
    public interface alloc {

        long apply(java.lang.foreign.MemoryAddress _x0, int _x1, long _x2, long _x3);
        static MemorySegment allocate(alloc fi, MemorySession session) {
            return RuntimeHelper.upcallStub(alloc.class, fi, H5FD_class_t.alloc$FUNC, session);
        }
        static alloc ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, long __x2, long __x3) -> {
                try {
                    return (long)H5FD_class_t.alloc$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle alloc$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("alloc"));
    public static VarHandle alloc$VH() {
        return H5FD_class_t.alloc$VH;
    }
    public static MemoryAddress alloc$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.alloc$VH.get(seg);
    }
    public static void alloc$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.alloc$VH.set(seg, x);
    }
    public static MemoryAddress alloc$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.alloc$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void alloc$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.alloc$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static alloc alloc (MemorySegment segment, MemorySession session) {
        return alloc.ofAddress(alloc$get(segment), session);
    }
    static final FunctionDescriptor free$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle free$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.free$FUNC
    );
    public interface free {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, long _x2, long _x3, long _x4);
        static MemorySegment allocate(free fi, MemorySession session) {
            return RuntimeHelper.upcallStub(free.class, fi, H5FD_class_t.free$FUNC, session);
        }
        static free ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, long __x2, long __x3, long __x4) -> {
                try {
                    return (int)H5FD_class_t.free$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle free$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("free"));
    public static VarHandle free$VH() {
        return H5FD_class_t.free$VH;
    }
    public static MemoryAddress free$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.free$VH.get(seg);
    }
    public static void free$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.free$VH.set(seg, x);
    }
    public static MemoryAddress free$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.free$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void free$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.free$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static free free (MemorySegment segment, MemorySession session) {
        return free.ofAddress(free$get(segment), session);
    }
    static final FunctionDescriptor get_eoa$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle get_eoa$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.get_eoa$FUNC
    );
    public interface get_eoa {

        long apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(get_eoa fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_eoa.class, fi, H5FD_class_t.get_eoa$FUNC, session);
        }
        static get_eoa ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (long)H5FD_class_t.get_eoa$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_eoa$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_eoa"));
    public static VarHandle get_eoa$VH() {
        return H5FD_class_t.get_eoa$VH;
    }
    public static MemoryAddress get_eoa$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_eoa$VH.get(seg);
    }
    public static void get_eoa$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.get_eoa$VH.set(seg, x);
    }
    public static MemoryAddress get_eoa$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_eoa$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_eoa$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.get_eoa$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_eoa get_eoa (MemorySegment segment, MemorySession session) {
        return get_eoa.ofAddress(get_eoa$get(segment), session);
    }
    static final FunctionDescriptor set_eoa$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle set_eoa$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.set_eoa$FUNC
    );
    public interface set_eoa {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, long _x2);
        static MemorySegment allocate(set_eoa fi, MemorySession session) {
            return RuntimeHelper.upcallStub(set_eoa.class, fi, H5FD_class_t.set_eoa$FUNC, session);
        }
        static set_eoa ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, long __x2) -> {
                try {
                    return (int)H5FD_class_t.set_eoa$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle set_eoa$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("set_eoa"));
    public static VarHandle set_eoa$VH() {
        return H5FD_class_t.set_eoa$VH;
    }
    public static MemoryAddress set_eoa$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.set_eoa$VH.get(seg);
    }
    public static void set_eoa$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.set_eoa$VH.set(seg, x);
    }
    public static MemoryAddress set_eoa$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.set_eoa$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void set_eoa$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.set_eoa$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static set_eoa set_eoa (MemorySegment segment, MemorySession session) {
        return set_eoa.ofAddress(set_eoa$get(segment), session);
    }
    static final FunctionDescriptor get_eof$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle get_eof$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.get_eof$FUNC
    );
    public interface get_eof {

        long apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(get_eof fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_eof.class, fi, H5FD_class_t.get_eof$FUNC, session);
        }
        static get_eof ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (long)H5FD_class_t.get_eof$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_eof$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_eof"));
    public static VarHandle get_eof$VH() {
        return H5FD_class_t.get_eof$VH;
    }
    public static MemoryAddress get_eof$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_eof$VH.get(seg);
    }
    public static void get_eof$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.get_eof$VH.set(seg, x);
    }
    public static MemoryAddress get_eof$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_eof$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_eof$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.get_eof$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_eof get_eof (MemorySegment segment, MemorySession session) {
        return get_eof.ofAddress(get_eof$get(segment), session);
    }
    static final FunctionDescriptor get_handle$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle get_handle$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.get_handle$FUNC
    );
    public interface get_handle {

        int apply(java.lang.foreign.MemoryAddress _x0, long _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(get_handle fi, MemorySession session) {
            return RuntimeHelper.upcallStub(get_handle.class, fi, H5FD_class_t.get_handle$FUNC, session);
        }
        static get_handle ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, long __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)H5FD_class_t.get_handle$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle get_handle$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_handle"));
    public static VarHandle get_handle$VH() {
        return H5FD_class_t.get_handle$VH;
    }
    public static MemoryAddress get_handle$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_handle$VH.get(seg);
    }
    public static void get_handle$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.get_handle$VH.set(seg, x);
    }
    public static MemoryAddress get_handle$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.get_handle$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void get_handle$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.get_handle$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static get_handle get_handle (MemorySegment segment, MemorySession session) {
        return get_handle.ofAddress(get_handle$get(segment), session);
    }
    static final FunctionDescriptor read$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.read$FUNC
    );
    public interface read {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, long _x2, long _x3, long _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(read fi, MemorySession session) {
            return RuntimeHelper.upcallStub(read.class, fi, H5FD_class_t.read$FUNC, session);
        }
        static read ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, long __x2, long __x3, long __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)H5FD_class_t.read$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3, __x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read"));
    public static VarHandle read$VH() {
        return H5FD_class_t.read$VH;
    }
    public static MemoryAddress read$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.read$VH.get(seg);
    }
    public static void read$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.read$VH.set(seg, x);
    }
    public static MemoryAddress read$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.read$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.read$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read read (MemorySegment segment, MemorySession session) {
        return read.ofAddress(read$get(segment), session);
    }
    static final FunctionDescriptor write$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.write$FUNC
    );
    public interface write {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1, long _x2, long _x3, long _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(write fi, MemorySession session) {
            return RuntimeHelper.upcallStub(write.class, fi, H5FD_class_t.write$FUNC, session);
        }
        static write ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, long __x2, long __x3, long __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)H5FD_class_t.write$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3, __x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write"));
    public static VarHandle write$VH() {
        return H5FD_class_t.write$VH;
    }
    public static MemoryAddress write$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.write$VH.get(seg);
    }
    public static void write$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.write$VH.set(seg, x);
    }
    public static MemoryAddress write$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.write$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.write$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write write (MemorySegment segment, MemorySession session) {
        return write.ofAddress(write$get(segment), session);
    }
    static final FunctionDescriptor flush$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_BOOL$LAYOUT
    );
    static final MethodHandle flush$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.flush$FUNC
    );
    public interface flush {

        int apply(java.lang.foreign.MemoryAddress _x0, long _x1, boolean _x2);
        static MemorySegment allocate(flush fi, MemorySession session) {
            return RuntimeHelper.upcallStub(flush.class, fi, H5FD_class_t.flush$FUNC, session);
        }
        static flush ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, long __x1, boolean __x2) -> {
                try {
                    return (int)H5FD_class_t.flush$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle flush$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("flush"));
    public static VarHandle flush$VH() {
        return H5FD_class_t.flush$VH;
    }
    public static MemoryAddress flush$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.flush$VH.get(seg);
    }
    public static void flush$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.flush$VH.set(seg, x);
    }
    public static MemoryAddress flush$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.flush$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void flush$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.flush$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static flush flush (MemorySegment segment, MemorySession session) {
        return flush.ofAddress(flush$get(segment), session);
    }
    static final FunctionDescriptor truncate$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_BOOL$LAYOUT
    );
    static final MethodHandle truncate$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.truncate$FUNC
    );
    public interface truncate {

        int apply(java.lang.foreign.MemoryAddress _x0, long _x1, boolean _x2);
        static MemorySegment allocate(truncate fi, MemorySession session) {
            return RuntimeHelper.upcallStub(truncate.class, fi, H5FD_class_t.truncate$FUNC, session);
        }
        static truncate ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, long __x1, boolean __x2) -> {
                try {
                    return (int)H5FD_class_t.truncate$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle truncate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("truncate"));
    public static VarHandle truncate$VH() {
        return H5FD_class_t.truncate$VH;
    }
    public static MemoryAddress truncate$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.truncate$VH.get(seg);
    }
    public static void truncate$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.truncate$VH.set(seg, x);
    }
    public static MemoryAddress truncate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.truncate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void truncate$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.truncate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static truncate truncate (MemorySegment segment, MemorySession session) {
        return truncate.ofAddress(truncate$get(segment), session);
    }
    static final FunctionDescriptor lock$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_BOOL$LAYOUT
    );
    static final MethodHandle lock$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.lock$FUNC
    );
    public interface lock {

        int apply(java.lang.foreign.MemoryAddress _x0, boolean _x1);
        static MemorySegment allocate(lock fi, MemorySession session) {
            return RuntimeHelper.upcallStub(lock.class, fi, H5FD_class_t.lock$FUNC, session);
        }
        static lock ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, boolean __x1) -> {
                try {
                    return (int)H5FD_class_t.lock$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle lock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("lock"));
    public static VarHandle lock$VH() {
        return H5FD_class_t.lock$VH;
    }
    public static MemoryAddress lock$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.lock$VH.get(seg);
    }
    public static void lock$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.lock$VH.set(seg, x);
    }
    public static MemoryAddress lock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.lock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void lock$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.lock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static lock lock (MemorySegment segment, MemorySession session) {
        return lock.ofAddress(lock$get(segment), session);
    }
    static final FunctionDescriptor unlock$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unlock$MH = RuntimeHelper.downcallHandle(
        H5FD_class_t.unlock$FUNC
    );
    public interface unlock {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(unlock fi, MemorySession session) {
            return RuntimeHelper.upcallStub(unlock.class, fi, H5FD_class_t.unlock$FUNC, session);
        }
        static unlock ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)H5FD_class_t.unlock$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unlock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unlock"));
    public static VarHandle unlock$VH() {
        return H5FD_class_t.unlock$VH;
    }
    public static MemoryAddress unlock$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.unlock$VH.get(seg);
    }
    public static void unlock$set( MemorySegment seg, MemoryAddress x) {
        H5FD_class_t.unlock$VH.set(seg, x);
    }
    public static MemoryAddress unlock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)H5FD_class_t.unlock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unlock$set(MemorySegment seg, long index, MemoryAddress x) {
        H5FD_class_t.unlock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unlock unlock (MemorySegment segment, MemorySession session) {
        return unlock.ofAddress(unlock$get(segment), session);
    }
    public static MemorySegment fl_map$slice(MemorySegment seg) {
        return seg.asSlice(248, 28);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


