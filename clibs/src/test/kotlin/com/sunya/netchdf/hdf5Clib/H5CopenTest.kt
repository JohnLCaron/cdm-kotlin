package com.sunya.netchdf.hdf5Clib

import com.google.common.util.concurrent.AtomicDouble
import com.sunya.cdm.api.Netchdf
import com.sunya.cdm.api.Variable
import com.sunya.cdm.api.chunkConcurrent
import com.sunya.cdm.array.ArrayTyped
import com.sunya.cdm.util.Stats
import com.sunya.netchdf.hdf5.Hdf5File
import com.sunya.netchdf.netcdf4.openNetchdfFile
import com.sunya.netchdf.netcdfClib.NetcdfClibFile
import com.sunya.testdata.H5CFiles
import com.sunya.testdata.H5Files
import com.sunya.testdata.testData
import com.sunya.testdata.testFilesIn

import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Test
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.Arguments
import org.junit.jupiter.params.provider.MethodSource
import java.util.stream.Stream
import kotlin.system.measureNanoTime
import kotlin.test.assertEquals

// Sanity check read Hdf5File header, for non-netcdf4 files
class H5CopenTest {

    companion object {
        @JvmStatic
        fun params(): Stream<Arguments> {
            return Stream.of( H5CFiles.params()).flatMap { i -> i };
        }

        @JvmStatic
        @BeforeAll
        fun beforeAll() {
            Stats.clear()
        }

        @JvmStatic
        @AfterAll
        fun afterAll() {
            if (versions.size > 0) {
                versions.keys.forEach{ println("$it = ${versions[it]!!.size } files") }
            }
            Stats.show()
        }

        private val versions = mutableMapOf<String, MutableList<String>>()
    }

    @Test
    fun problem() {
        testOpenH5C(testData + "cdmUnitTest/formats/hdf5/ssec-h5/K01_VHR_28AUG2007_0000_L02_IND.h5")
    }

    ///////////////////////////////////////////////////////////////////////////////////

    @ParameterizedTest
    @MethodSource("params")
    fun checkVersion(filename: String) {
        openNetchdfFile(filename).use { ncfile ->
            if (ncfile == null) {
                println("Not a netchdf file=$filename ")
                return
            }
            println("${ncfile.type()} $filename ")
            val paths = versions.getOrPut(ncfile.type()) { mutableListOf() }
            paths.add(filename)
        }
    }

    @ParameterizedTest
    @MethodSource("params")
    fun testOpenH5C(filename: String) {
        openH5(filename, null)
    }

    @ParameterizedTest
    @MethodSource("params")
    fun compareWithH5Clib(filename: String) {
        println("=================")
        Hdf5File(filename, true).use { h5file ->
            println("${h5file.type()} $filename ")
            println("\n${h5file.cdl()}")

            Hdf5ClibFile(filename).use { hclibfile ->
                println("ncfile = ${hclibfile.cdl()}")
                assertEquals(hclibfile.cdl(), h5file.cdl())
            }
        }
    }

    /////////////////////////////////////////////////////////

    fun openH5(filename: String, varname : String? = null) {
        println("=================")
        println(filename)
        Hdf5ClibFile(filename).use { h5file ->
            println(h5file.cdl())
            h5file.rootGroup().allVariables().forEach { println("  ${it.fullname()}") }

            if (varname != null) {
                val h5var = h5file.rootGroup().allVariables().find { it.fullname() == varname } ?: throw RuntimeException("cant find $varname")
                val h5data = h5file.readArrayData(h5var)
                println(" $varname = $h5data")
            }
        }
    }

}